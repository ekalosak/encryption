'''
Author: Eric Kalosa-Kenyon
Date: 2015, 10, 2

Encrypt and decrypt strings using RSA
'''

import string
import random
from copy import copy

import numpy as np
import math
import pdb

import primes

VALID_CHR = string.ascii_uppercase

def make_keys(n_primes = 100, pq_bound = 100):
    '''
    takes: int n
    returns: tuples_int pub, prv
    '''

    n, p, q = 1, 1, 1
    prms = primes.prime(n_primes)
    while math.log(n, 2) <= 1:
        while n < pq_bound:
            p, q = np.random.choice(prms, size = 2, replace = False)
            n = p * q
    print "Key bit length: {}".format(math.log(n, 2))
    print "Generated by p: {} and q: {}".format(p, q)

    t = (p - 1) * (q - 1) # =: |{k | k < n && (k, n) == 0}|
    print "Euler's totient function of {}x{}={}: {}".format(p, q, n, t)

    e = t
    while primes.gcd(e, t) != 1 or e == 1:
        e = int(np.random.uniform(low = 1, high = t))
    print "Public key: {}".format(e)

    d = primes.inv(e, t)
    print "Private key: {}".format(d)

    return (n, e), (n, d)

def str_to_int(msg):
    n = 1
    for l in msg:
        n = n * len(VALID_CHR) + VALID_CHR.index(l)
    return n

def int_to_str(n):
    s = ''
    N = len(VALID_CHR)
    while len(s) < math.log(n, N):
        m = n % N
        s = VALID_CHR[m] + s
        n = (n - m) / N
    if n > 1:
        s = VALID_CHR[n] + s
    return s

def encrypt(msg, pub):
    '''
    takes: string msg, key pub
    returns: int encrypted msg
    '''
    n, e = pub
    m = str_to_int(msg)
    c = m ** e % n
    print "Encrypted {} as {}".format(msg, c)
    return c

def decrypt(enc, prv):
    '''
    takes: int encrypted msg, key prv
    returns: string decrypted msg
    '''
    n, d = prv
    m = enc ** d % n
    msg = int_to_str(m)
    print "Decrypted {} to {}".format(enc, msg)
    return msg

def make_random_string(size=6):
    r = ''.join(random.choice(VALID_CHR) for _ in range(size))
    print "Random string: {}".format(r)
    return r

def test():

    string_size = 2

    n_primes = string_size * len(VALID_CHR)
    # that bound assumes nth_prime(x) ~ e^x, which is unknown
    # pq_bound = math.sqrt(string_size ** len(VALID_CHR))
    pq_bound = len(VALID_CHR) ** string_size

    pub, prv = make_keys(n_primes = n_primes, pq_bound = pq_bound)

    msg = make_random_string(size = string_size)
    enc = encrypt(msg, pub)
    dec = decrypt(enc, prv)

    try:
        assert dec == msg
    except AssertionError as e:
        pdb.set_trace()

    print "Passed tests!!"

def main():
    pass

if __name__ == '__main__':
    test()
    main()
